# 第三章-内存管理

## 3.1 内存管理的概念

### 3.1.1 内存的基础知识

![image-20220924152446545](C:/Users/%E5%B0%8F%E6%96%B0/AppData/Roaming/Typora/typora-user-images/image-20220924152446545.png)

![](C:/Users/%E5%B0%8F%E6%96%B0/AppData/Roaming/Typora/typora-user-images/image-20220924152524595.png)

![image-20220924152533518](C:/Users/%E5%B0%8F%E6%96%B0/AppData/Roaming/Typora/typora-user-images/image-20220924152533518.png)

![image-20220924152845546](C:/Users/%E5%B0%8F%E6%96%B0/AppData/Roaming/Typora/typora-user-images/image-20220924152845546.png)

![image-20220924152923721](C:/Users/%E5%B0%8F%E6%96%B0/AppData/Roaming/Typora/typora-user-images/image-20220924152923721.png)

 ![image-20220924153230395](assets/image-20220924153230395.png)

![image-20220924153549051](assets/image-20220924153549051.png)

![image-20220924153857272](assets/image-20220924153857272.png)

![image-20220924154340916](assets/image-20220924154340916.png)

==可执行文件==又可以称为装入模块。

![image-20220924154740684](assets/image-20220924154740684.png)

程序编译，链接...之后所形成的地址一般来说，使用的是逻辑地址。物理地址是无法确定的，那么如何将逻辑地址转换为正确的物理地址呢?

![image-20220924155230870](assets/image-20220924155230870.png)

![image-20220924161719557](assets/image-20220924161719557.png)

灵活性低，可移植性差。

![image-20220924162131807](assets/image-20220924162131807.png)

![image-20220924162635539](assets/image-20220924162635539.png)

![image-20220924162910459](assets/image-20220924162910459.png)

![image-20220924165517490](assets/image-20220924165517490.png)

![image-20220924165824400](assets/image-20220924165824400.png)

![image-20220924165930716](assets/image-20220924165930716.png)

![image-20220924170017068](assets/image-20220924170017068.png)

![image-20220924170021224](assets/image-20220924170021224.png)

![image-20220924170217713](assets/image-20220924170217713.png)

### 3.1.2 内存管理的概念

![image-20220924170611476](assets/image-20220924170611476.png)

![image-20220924170733210](assets/image-20220924170733210.png)

![image-20220924170946490](assets/image-20220924170946490.png)

![image-20220924183418099](assets/image-20220924183418099.png)

![image-20220924183647031](assets/image-20220924183647031.png)

![image-20220924183754099](assets/image-20220924183754099.png)

### 3.1.3 覆盖与交换技术

![image-20220924190223214](assets/image-20220924190223214.png)

![image-20220924190553083](assets/image-20220924190553083.png)

![image-20220924191041261](assets/image-20220924191041261.png)

![image-20220924191349864](assets/image-20220924191349864.png)

![image-20220924191630090](assets/image-20220924191630090.png)

对换区的I/O速度比文件区更快。

![image-20220924191916769](assets/image-20220924192121904.png)

PCB会常驻内存，不会被换出外存。

覆盖技术与交换技术的区别：

- 覆盖技术是根据覆盖结构，让同一个进程中的，在同一调用级别的程序段，在不同的时期，共用同一块内存空间。

- 交换技术是内存紧张时，换出某些进程以腾出内存空间，在换入某些进程。

### 3.1.4 连续分配管理方式

![image-20220924193240173](assets/image-20220924193240173.png)

![image-20220924193530576](assets/image-20220924193530576.png)

![image-20220924193630317](assets/image-20220924193630317.png)

![image-20220924194105895](assets/image-20220924194105895.png)

![image-20220924194250606](assets/image-20220924194250606.png)

![image-20220924194345271](assets/image-20220924194345271.png)

![image-20220924194427607](assets/image-20220924194427607.png)

![image-20220924194701586](assets/image-20220924194701586.png)

![image-20220924194833911](assets/image-20220924194833911.png)

![image-20220924195010063](assets/image-20220924195010063.png)

![image-20220924195126376](assets/image-20220924195126376.png)

![image-20220924195243712](assets/image-20220924195243712.png)

![image-20220924195415805](assets/image-20220924195415805.png)

![image-20220924195446210](assets/image-20220924195446210.png)

![image-20220924195547276](assets/image-20220924195547276.png)

![image-20220924195648988](assets/image-20220924195648988.png)

在进行内存分区回收的时候，如果发现，回收了之后，发现有一些空闲分区是相邻的，那么我们就需要把这些相邻的空闲分区全部给合并。

![image-20220924200113122](assets/image-20220924200113122.png)

![image-20220924200228700](assets/image-20220924200228700.png)

![image-20220924200456101](assets/image-20220924200456101.png)

### 3.1.5 动态分区分配算法

![image-20220924200755356](assets/image-20220924200755356.png)

![image-20220924201006138](assets/image-20220924201006138.png)

![image-20220924201049796](assets/image-20220924201049796.png)

![image-20220924201132433](assets/image-20220924201132433.png)

![image-20220924201724090](assets/image-20220924201724090.png)

最佳适应算法的缺点：会产生很多的外部碎片。

![image-20220924201958321](assets/image-20220924201958321.png)

![image-20220924202043160](assets/image-20220924202043160.png)

![image-20220924202609742](assets/image-20220924202609742.png)

![image-20220924202658520](assets/image-20220924202658520.png)

![image-20220924202705459](assets/image-20220924202705459.png)

==最佳适应算法和最坏适应算法算法开销大==是因为这两个算法每次分配内存空间后，空闲分区表或者空闲分区链都要重新排列；而==首次适应算法和邻居适应算法==则不用重新排列，因此它们的==算法开销较小==。

### 3.1.6 基本分页存储管理的概念

![image-20220924205118359](assets/image-20220924205118359.png)

![image-20220924205631221](assets/image-20220924205631221.png)

![image-20220924205814967](assets/image-20220924205814967.png)

页框（page frame）。

![image-20220924210343544](assets/image-20220924210343544.png)

![image-20220924210615197](assets/image-20220924210615197.png)

![image-20220924210807506](assets/image-20220924210807506.png)

![image-20220924210930727](assets/image-20220924210930727.png)

 ![image-20220924211118901](assets/image-20220924211118901.png)

![image-20220924211109709](assets/image-20220924211109709.png)

![image-20220924211612657](assets/image-20220924211612657.png)

![image-20220924211802600](assets/image-20220924211802600.png)

![image-20220924211904593](assets/image-20220924211904593.png)

![image-20220924212250341](assets/image-20220924212250341.png)

![image-20220924212334228](assets/image-20220924212334228.png)

![image-20220924212648726](assets/image-20220924212648726.png)

![image-20220924212736333](assets/image-20220924212736333.png)

![image-20220924212755051](assets/image-20220924212755051.png)

![image-20220924212912511](assets/image-20220924212912511.png)

![image-20220924212928853](assets/image-20220924212928853.png)

![image-20220924212942425](assets/image-20220924212942425.png)

![image-20220924213233422](assets/image-20220924213233422.png)

### 3.1.7 基本地址变换机构

![image-20220924213633399](assets/image-20220924213633399.png)

![image-20220924213855022](assets/image-20220924213855022.png)

![image-20220924214106147](assets/image-20220924214106147.png)

![image-20220924214350572](assets/image-20220924214350572.png)

![image-20220924214901087](assets/image-20220924214901087.png)

$\text{物理块号} \times \text{物理快长度} = \text{物理块起始地址}$

![image-20220924215302186](image-20220924215302186.png)

![image-20220924215508716](assets/image-20220924215508716.png)

![image-20220924215722768](assets/image-20220924215722768.png)

![image-20220924220303953](assets/image-20220924220303953.png)

==注意==对页号进行越界检查。

![image-20220925172237520](assets/image-20220925172237520.png)

![image-20220925172551899](assets/image-20220925172551899.png)

![image-20220925172748263](assets/image-20220925172748263.png)

进程页表通常是<font color=red>装在连续的内存块中</font>的。

![image-20220925172905972](assets/image-20220925172905972.png)

页式管理中地址是一维的，知道==逻辑地址==，就可以求出==物理地址==

### 3.1.8 具有块表的地址变换机构

![image-20220925173611245](assets/image-20220925173611245.png)

快表（TLB）和我们狭义上的高速缓存也是有区别的。

![image-20220925174203205](assets/image-20220925174203205.png)

![image-20220925174329316](assets/image-20220925174329316.png)

![image-20220925175039176](assets/image-20220925175039176.png)

![image-20220925184542044](assets/image-20220925184542044.png)

![image-20220925185145759](assets/image-20220925185145759.png)

![image-20220925185239034](assets/image-20220925185239034.png)

![image-20220925185632202](assets/image-20220925185632202.png)

![image-20220925185640133](assets/image-20220925185640133.png)

![image-20220925185847323](assets/image-20220925185847323.png)

### 3.1.9 两级页表

![image-20220925190845863](assets/image-20220925190845863.png)

![image-20220925190947392](assets/image-20220925190947392.png)

![image-20220925191215685](assets/image-20220925191215685.png)

![image-20220925191508350](assets/image-20220925191508350.png)

![image-20220925191807953](assets/image-20220925191807953.png)

![image-20220925191921100](assets/image-20220925191921100.png)

![image-20220925192120580](assets/image-20220925192120580.png)

![image-20220925192248752](assets/image-20220925192248752.png)

![image-20220925192349187](assets/image-20220925192349187.png)

![image-20220925192548950](assets/image-20220925192548950.png)

![image-20220925192802412](assets/image-20220925192802412.png)

没有块表机构的话，`n`级页表在访问一个逻辑地址的时候，访存次数应该为`n+1`次。

![image-20220925193057170](assets/image-20220925193057170.png)

![image-20220925193252873](assets/image-20220925193252873.png)

### 3.1.10 基本分段存储管理

![image-20220926213642627](assets/image-20220926213642627.png)

![image-20220926214133590](assets/image-20220926214133590.png)

![image-20220926214611778](assets/image-20220926214611778.png)

![image-20220926214847649](assets/image-20220926214847649.png)

![image-20220926215425232](assets/image-20220926215425232.png)

![image-20220927095314790](assets/image-20220927095314790.png)

![image-20220927095457513](assets/image-20220927095457513.png)

![image-20220927095631255](assets/image-20220927095631255.png)

![image-20220927095945887](assets/image-20220927095945887.png)

![image-20220927100056626](assets/image-20220927100056626.png)

![image-20220927100412847](assets/image-20220927100412847.png)

![image-20220927100650686](assets/image-20220927100650686.png)

![image-20220927101012150](assets/image-20220927101012150.png)

![image-20220927101119924](assets/image-20220927101119924.png)

![image-20220927101244685](assets/image-20220927101244685.png)

###3.1.11 段页式管理方式

![image-20220927101439776](assets/image-20220927101439776.png)

![image-20220927101634328](assets/image-20220927101634328.png)

![image-20220927101826610](assets/image-20220927101826610.png)

![image-20220927102142005](assets/image-20220927102142005.png)

“分段”对用户是可见的，程序员编程时需要显式地给出段号，段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。

![image-20220927102657374](assets/image-20220927102657374.png)

![image-20220927102946442](assets/image-20220927102946442.png)

![image-20220927103011586](assets/image-20220927103011586.png)

![image-20220927103029601](assets/image-20220927103029601.png)

![image-20220927103442203](assets/image-20220927103442203.png)

## 3.2 虚拟内存管理

### 3.2.1 虚拟内存的基本概念

![image 1](assets/image%201.png)

![image-20220927132035014](assets/image-20220927132035014.png)

![image-20220927132519848](assets/image-20220927132519848.png)

![image-20220927132640621](assets/image-20220927132640621.png)

![image-20220927132715550](assets/image-20220927132715550.png)

![image-20220927132824486](assets/image-20220927132824486.png)

![image-20220927132843088](assets/image-20220927132843088.png)

使用了虚拟内存技术后，对内存的利用率，系统的性能，都是有所提升的。

![image-20220927133031999](assets/image-20220927133031999.png)

![image-20220927133147205](assets/image-20220927133147205.png)

![image-20220927133223382](assets/image-20220927133223382.png)

![image-20220927133422120](assets/image-20220927133422120.png)

### 3.2.2 请求分页管理方式

![image-20220927144931844](assets/image-20220927144931844.png)

![image-20220927145225251](assets/image-20220927145225251.png)

![image-20220927145235227](assets/image-20220927145235227.png)

![image-20220927145607107](assets/image-20220927145607107.png)

![image-20220927145703120](assets/image-20220927145703120.png)

![image-20220927145853417](assets/image-20220927145853417.png)

![image-20220927150034213](assets/image-20220927150034213.png)

![image-20220927150158592](assets/image-20220927150158592.png)

![image-20220927150329310](assets/image-20220927150329310.png)

![image-20220927150415720](assets/image-20220927150415720.png)

![image-20220927150551332](assets/image-20220927150551332.png)

![image-20220927150703934](assets/image-20220927150703934.png)

![image-20220927150755520](assets/image-20220927150755520.png)

![image-20220927150909686](assets/image-20220927150909686.png)

![image-20220927151121814](assets/image-20220927151121814.png)

### 3.2.3 页面置换算法

![image-20220927152633770](assets/image-20220927152633770.png)

![image-20220927153118245](assets/image-20220927153118245.png)

![image-20220927153202805](assets/image-20220927153202805.png)

![image-20220927153242307](assets/image-20220927153242307.png)

![image-20220927153312051](assets/image-20220927153312051.png)

![image-20220927153530521](assets/image-20220927153530521.png)

![image-20220927153627317](assets/image-20220927153627317.png)

![image-20220927153705713](assets/image-20220927153705713.png)

![image-20220927153816438](assets/image-20220927153816438.png)

![image-20220927154223564](assets/image-20220927154223564.png)

![image-20220927154314157](assets/image-20220927154314157.png)

![image-20220927154545129](assets/image-20220927154545129.png)

![image-20220927154657264](assets/image-20220927154657264.png)

![image-20220927154807454](assets/image-20220927154807454.png)

![image-20220927155245834](assets/image-20220927155245834.png)

![image-20220927155336654](assets/image-20220927155336654.png)

![image-20220927155426528](assets/image-20220927155426528.png)

![image-20220927155456265](assets/image-20220927155456265.png)

![image-20220927155515928](assets/image-20220927155515928.png)

![image-20220927155629439](assets/image-20220927155629439.png)

![image-20220927155656746](assets/image-20220927155656746.png)

### 3.2.4 页面分配策略，抖动，工作集

![image-20220927161445527](assets/image-20220927161445527.png)

![image-20220927161639744](assets/image-20220927161639744.png)

![image-20220927161831378](assets/image-20220927161831378.png)

![image-20220927162120621](assets/image-20220927162120621.png)

![image-20220927162351390](assets/image-20220927162351390.png)

![image-20220927163010704](assets/image-20220927163010704.png)

调入页面的时机问题

![image-20220927163341846](assets/image-20220927163341846.png)

 ![image-20220927163620135](assets/image-20220927163620135.png)

![image-20220927163808687](assets/image-20220927163808687.png)

![image-20220927163857525](assets/image-20220927163857525.png)

![image-20220927164009342](assets/image-20220927164009342.png)

![image-20220927164151749](assets/image-20220927164151749.png)

![image-20220927164213066](assets/image-20220927164213066.png)

![image-20220927164232259](assets/image-20220927164232259.png)

![image-20220927164236221](assets/image-20220927164236221.png)

![image-20220927164502523](assets/image-20220927164502523.png)

### 3.2.5 内存映射文件

![image-20220927164709540](assets/image-20220927164709540.png)

![image-20220927164831165](assets/image-20220927164831165.png)

![image-20220927165054604](assets/image-20220927165054604.png)

![image-20220927165421917](assets/image-20220927165421917.png)

![image-20220927165728165](assets/image-20220927165728165.png)

![image-20220927165855950](assets/image-20220927165855950.png)

![image-20220927165908143](assets/image-20220927165908143.png)

